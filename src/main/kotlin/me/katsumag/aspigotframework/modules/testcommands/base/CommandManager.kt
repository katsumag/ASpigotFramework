package me.katsumag.aspigotframework.modules.testcommands.base

import me.katsumag.aspigotframework.modules.testcommands.annotations.Alias
import me.katsumag.aspigotframework.modules.testcommands.exceptions.CommandException
import org.bukkit.Bukkit
import org.bukkit.command.Command
import org.bukkit.command.CommandMap
import org.bukkit.command.PluginIdentifiableCommand
import org.bukkit.command.SimpleCommandMap
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.server.PluginDisableEvent
import org.bukkit.plugin.Plugin
import java.util.*
import java.util.function.Consumer
import java.util.logging.Level
import kotlin.collections.HashMap

class CommandManager @JvmOverloads constructor(// The plugin's main class
        private val plugin: Plugin, hideTab: Boolean = false) : Listener {
    // The command map
    private val commandMap: CommandMap?

    // List of commands;
    private val commands: MutableMap<String, CommandHandler> = HashMap()
    private var bukkitCommands: MutableMap<String, Command> = HashMap()

    /**
     * Gets the parameter types class to register new ones and to check too.
     *
     * @return The parameter types class.
     */
    // The parameter handler
    val parameterHandler = ParameterHandler()

    /**
     * Gets the completion handler class, which handles all the command completions in the plugin.
     *
     * @return The completion handler.
     */
    // The completion handler
    val completionHandler = CompletionHandler()

    /**
     * Gets the message handler, which handles all the messages autogenerated by the framework.
     *
     * @return The message handler.
     */
    // The messages handler
    val messageHandler = MessageHandler()

    // If should or not hide tab complete for no permissions
    private var hideTab: Boolean

    /**
     * Registers commands.
     *
     * @param commands The list of command classes to register.
     */
    fun register(vararg commands: CommandBase) {
        for (command in commands) {
            register(command)
        }
    }

    /**
     * Registers a command.
     *
     * @param command The command class to register.
     */
    fun register(command: CommandBase) {
        // Calls the code to run on command register
        command.onRegister()
        val commandClass: Class<*> = command.javaClass

        // Checks for the command annotation.
        if (!commandClass.isAnnotationPresent(me.katsumag.aspigotframework.modules.testcommands.annotations.Command::class.java)) {
            throw CommandException("Class $command.javaClass.name needs to have @Command!")
        }

        // Gets the command annotation value.
        val commandName: String = commandClass.getAnnotation(me.katsumag.aspigotframework.modules.testcommands.annotations.Command::class.java).name
        // Gets the aliases from the setAlias method
        val aliases = command.aliases.toMutableList()

        //Checks if the class has some alias and adds them.
        if (commandClass.isAnnotationPresent(Alias::class.java)) {
            aliases.addAll(commandClass.getAnnotation(Alias::class.java).aliases)
        }
        val oldCommand = commandMap!!.getCommand(commandName)

        // From ACF
        // To allow commands to be registered on the plugin.yml
        if (oldCommand is PluginIdentifiableCommand && (oldCommand as PluginIdentifiableCommand).plugin === plugin) {
            bukkitCommands.remove(commandName)
            oldCommand.unregister(commandMap)
        }

        // Used to get the command map to register the commands.
        try {
            if (commands.containsKey(commandName)) {
                commands[commandName]!!.addSubCommands(command)
                return
            }

            // Sets the message handler to be used in the command class
            command.messageHandler = messageHandler

            // Creates the command handler
            val commandHandler: CommandHandler = CommandHandler(parameterHandler, completionHandler,
                    messageHandler, command, commandName, aliases, hideTab)

            // Registers the command
            commandMap.register(commandName, plugin.name, commandHandler)

            // Puts the handler in the list to unregister later.
            commands[commandName] = commandHandler
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    /**
     * Sets whether you want to hide or not commands from tab completion if players don't have permission to use them.
     *
     * @param hideTab Hide or Not.
     */
    fun hideTabComplete(hideTab: Boolean) {
        this.hideTab = hideTab
        for (cmdName in commands.keys) {
            commands[cmdName]!!.setHideTab(hideTab)
        }
    }

    /**
     * Unregisters all the commands on the disable of the plugin.
     *
     * @param event PluginDisableEvent.
     */
    @EventHandler
    fun onPluginDisable(event: PluginDisableEvent) {
        if (event.plugin !== plugin) return
        unregisterAll()
    }

    /**
     * Unregisters all commands.
     */
    private fun unregisterAll() {
        commands.values.forEach(Consumer { command: CommandHandler -> command.unregister(commandMap!!) })
    }

    /**
     * Gets the Command Map to register the commands
     *
     * @return The Command Map
     */
    private fun getCommandMap(): CommandMap? {
        var commandMap: CommandMap? = null
        try {
            val server = Bukkit.getServer()
            val getCommandMap = server.javaClass.getDeclaredMethod("getCommandMap")
            getCommandMap.isAccessible = true
            commandMap = getCommandMap.invoke(server) as CommandMap
            val bukkitCommands = SimpleCommandMap::class.java.getDeclaredField("knownCommands")
            bukkitCommands.isAccessible = true
            this.bukkitCommands = bukkitCommands[commandMap] as MutableMap<String, Command>
        } catch (e: Exception) {
            plugin.logger.log(Level.SEVERE, "Could not get Command Map, Commands won't be registered!")
        }
        return commandMap
    }
    /**
     * Constructor for the manager
     *
     * @param plugin  The plugin's main class
     * @param hideTab If should or not hide tab
     */
    /**
     * me.mattstudios.mf.Main constructor for the manager
     *
     * @param plugin The plugin's main class
     */
    init {
        plugin.server.pluginManager.registerEvents(this, plugin)
        this.hideTab = hideTab
        commandMap = getCommandMap()
    }
}